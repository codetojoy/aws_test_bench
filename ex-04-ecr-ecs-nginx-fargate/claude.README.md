# AWS ECR + ECS Terraform Starter Example

This example demonstrates how to use Terraform to create an AWS Elastic Container Registry (ECR) repository, push a Docker image to it, and deploy it to Amazon ECS with minimal computing resources.

## What This Does

1. Creates an ECR repository in AWS
2. Generates a simple Dockerfile with an nginx-based image
3. Builds the Docker image locally
4. Pushes the image to ECR
5. Sets up a lifecycle policy to manage old images
6. **Creates a VPC with public subnets**
7. **Deploys the container to ECS Fargate with public IP**
8. **Configures minimal resources (0.25 vCPU, 512MB RAM)**
9. **No load balancer - direct access via task public IP**

## Prerequisites

- **Terraform** (v1.0+): [Install Terraform](https://www.terraform.io/downloads)
- **Docker**: [Install Docker](https://docs.docker.com/get-docker/)
- **AWS CLI** configured with credentials: [Configure AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html)
- **AWS Account** with appropriate permissions for ECR, ECS, VPC, and IAM

## Required AWS Permissions

Your AWS user/role needs these permissions:
- `ecr:*` (ECR operations)
- `ecs:*` (ECS operations)
- `ec2:*` (VPC, subnets, security groups)
- `elasticloadbalancing:*` (ALB operations)
- `iam:*` (IAM roles for ECS)
- `logs:*` (CloudWatch logs)
- `application-autoscaling:*` (Optional, for scaling)

## Quick Start

### 1. Initialize Terraform

```bash
terraform init
```

This downloads the required providers (AWS and Docker).

### 2. Review the Plan

```bash
terraform plan
```

This shows what resources will be created (ECR, VPC, subnets, ECS, etc.).

### 3. Apply the Configuration

```bash
terraform apply
```

Type `yes` when prompted. This will:
- Create the ECR repository
- Build the Docker image
- Push the image to ECR
- Create VPC and networking components
- Deploy to ECS Fargate with public IP

**Note**: Deployment takes approximately 2-3 minutes.

### 4. Access Your Application

After successful deployment, get the task's public IP:

```bash
# Get cluster and service names
CLUSTER=$(terraform output -raw ecs_cluster_name)
SERVICE=$(terraform output -raw ecs_service_name)

# List tasks
TASK_ARN=$(aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --region us-east-1 --query 'taskArns[0]' --output text)

# Get task details and public IP
aws ecs describe-tasks --cluster $CLUSTER --tasks $TASK_ARN --region us-east-1 --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text | xargs -I {} aws ec2 describe-network-interfaces --network-interface-ids {} --region us-east-1 --query 'NetworkInterfaces[0].Association.PublicIp' --output text
```

Or use this simpler script:

```bash
# Save this as get-task-ip.sh
#!/bin/bash
CLUSTER=$(terraform output -raw ecs_cluster_name)
TASK_ARN=$(aws ecs list-tasks --cluster $CLUSTER --region us-east-1 --query 'taskArns[0]' --output text)
TASK_DETAILS=$(aws ecs describe-tasks --cluster $CLUSTER --tasks $TASK_ARN --region us-east-1)
ENI_ID=$(echo $TASK_DETAILS | jq -r '.tasks[0].attachments[0].details[] | select(.name=="networkInterfaceId") | .value')
PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --region us-east-1 --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
echo "Task Public IP: $PUBLIC_IP"
echo "Access your app at: http://$PUBLIC_IP"
```

Visit `http://<PUBLIC_IP>` in your browser to see your deployed application!

## Customization

You can customize the deployment by creating a `terraform.tfvars` file:

```hcl
aws_region         = "us-west-2"
repository_name    = "my-custom-app"
image_tag          = "v1.0.0"
ecs_task_cpu       = "512"    # 0.5 vCPU
ecs_task_memory    = "1024"   # 1GB RAM
ecs_desired_count  = 2        # Run 2 tasks
```

Or pass variables directly:

```bash
terraform apply \
  -var="repository_name=my-app" \
  -var="ecs_task_cpu=512" \
  -var="ecs_task_memory=1024"
```

### ECS Task Size Options (CPU/Memory combinations)

Fargate supports specific CPU/Memory combinations:

| CPU (vCPU) | Memory Options (MB) |
|------------|-------------------|
| 256 (0.25) | 512, 1024, 2048   |
| 512 (0.5)  | 1024 to 4096 (1GB increments) |
| 1024 (1)   | 2048 to 8192 (1GB increments) |
| 2048 (2)   | 4096 to 16384 (1GB increments) |

**Default (minimal)**: 256 CPU / 512 MB Memory

## File Structure

```
.
├── main.tf         # Main Terraform configuration
├── variables.tf    # Input variables
├── outputs.tf      # Output values
├── Dockerfile      # Generated by Terraform
└── README.md       # This file
```

## Accessing Your Application

### Get Task Public IP

Since there's no load balancer, you'll access the application directly via the ECS task's public IP:

```bash
# Quick method (requires jq)
CLUSTER=$(terraform output -raw ecs_cluster_name)
TASK_ARN=$(aws ecs list-tasks --cluster $CLUSTER --region us-east-1 --query 'taskArns[0]' --output text)
ENI_ID=$(aws ecs describe-tasks --cluster $CLUSTER --tasks $TASK_ARN --region us-east-1 --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --region us-east-1 --query 'NetworkInterfaces[0].Association.PublicIp' --output text)

echo "Access your app at: http://$PUBLIC_IP"

# Test it
curl http://$PUBLIC_IP
```

**Note**: The public IP changes when tasks restart. For production, use a load balancer or assign an Elastic IP.

### Monitor ECS Service

```bash
# View service status
aws ecs describe-services \
  --cluster $(terraform output -raw ecs_cluster_name) \
  --services $(terraform output -raw ecs_service_name) \
  --region us-east-1

# View running tasks
aws ecs list-tasks \
  --cluster $(terraform output -raw ecs_cluster_name) \
  --region us-east-1

# View logs
aws logs tail /ecs/demo-app --follow --region us-east-1
```

### Pull and Run Locally (Optional)

You can also pull and run the image locally:

```bash
# Get the image URI from outputs
IMAGE_URI=$(terraform output -raw image_uri)

# Login to ECR
aws ecr get-login-password --region us-east-1 | \
  docker login --username AWS --password-stdin $(terraform output -raw repository_url | cut -d'/' -f1)

# Pull the image
docker pull $IMAGE_URI

# Run the container locally
docker run -p 8080:80 $IMAGE_URI
```

Visit http://localhost:8080 to see the demo page.

## Cleanup

To destroy all created resources:

```bash
terraform destroy
```

**Important Notes**:
- ECS tasks will be stopped and terminated
- You may need to manually delete images from ECR if deletion protection is enabled
- VPC and all networking components will be removed

**Cost Reminder**: This configuration has minimal ongoing costs, but always destroy resources when not in use.

## Troubleshooting

### "exec format error" in ECS task logs
```
exec /docker-entrypoint.sh: exec format error
```
**Cause**: Docker image was built for the wrong architecture (ARM vs AMD64)

**Solution**: This is already fixed in the configuration. The Dockerfile build specifies `platform = "linux/amd64"` which is required for Fargate. If you still see this error:
1. Delete the local Docker image: `docker rmi $(terraform output -raw image_uri)`
2. Re-run: `terraform apply`

This commonly happens when building on Apple Silicon Macs (M1/M2/M3) which default to ARM64.

### Docker daemon not running
```
Error: Cannot connect to the Docker daemon
```
**Solution**: Start Docker Desktop or the Docker daemon.

### AWS credentials not found
```
Error: No valid credential sources found
```
**Solution**: Configure AWS CLI with `aws configure` or set environment variables.

### ECR authentication failed
```
Error: Cannot perform an interactive login from a non TTY device
```
**Solution**: Ensure Docker is running and you have internet connectivity.

### ECS tasks not starting
```
Service is unable to consistently start tasks successfully
```
**Solution**: 
- Check CloudWatch logs: `aws logs tail /ecs/demo-app --follow`
- Verify the image was pushed successfully to ECR
- Ensure the task has proper IAM permissions
- Check security group rules allow traffic from your IP

### Cannot access task public IP
**Solution**:
- Verify ECS tasks are in RUNNING state
- Check security group allows inbound traffic on port 80 from 0.0.0.0/0
- Ensure task has a public IP assigned
- Wait 1-2 minutes after task starts for network initialization
- Get the correct public IP using the commands in "Accessing Your Application"

### Task IP keeps changing
**Explanation**: 
- Public IPs change when tasks restart
- This is normal for ECS Fargate without a load balancer
- For stable access, consider adding an Application Load Balancer or Elastic IP

## Cost Optimization

This setup uses minimal resources to keep costs low:

- **Regular Fargate**: Standard pricing (no Spot for simplicity)
- **Minimal Task Size**: 0.25 vCPU / 512MB RAM
- **Single Task**: Only 1 running container
- **No Load Balancer**: Saves ~$16/month
- **No NAT Gateway**: Saves ~$32/month (tasks in public subnets)
- **7-day log retention**: Reduced CloudWatch storage

**Estimated Monthly Cost** (us-east-1, running 24/7):
- Fargate (0.25 vCPU, 512MB): ~$6/month
- Data transfer: ~$1-2/month
- CloudWatch logs: <$1/month
- **Total**: ~$7-9/month

**To reduce costs further**:
1. Stop tasks when not needed: `aws ecs update-service --cluster <cluster> --service <service> --desired-count 0`
2. Use Fargate Spot for ~70% savings (see DEPLOYMENT.md for how to enable)
3. Use scheduled scaling to run only during business hours
4. Delete resources when done: `terraform destroy`

## Architecture

```
Internet
    ↓
ECS Fargate Tasks (Public Subnets with Public IPs)
    ↓
Internet Gateway
    ↓
ECR (to pull Docker images)
```

**Key Points**:
- Tasks have public IPs and are directly accessible
- No NAT Gateway needed (saves cost)
- No Load Balancer (saves cost, but IP changes on restart)
- Suitable for development/testing or simple workloads

## Next Steps

- **Modify the Dockerfile** to use your own application
- **Add a load balancer** for stable DNS and automatic failover (see DEPLOYMENT.md)
- **Add auto-scaling** based on CPU/memory metrics
- **Set up CI/CD** integration to automate deployments
- **Configure HTTPS** by adding ALB with ACM certificate
- **Add CloudWatch alarms** for monitoring
- **Implement ECS Exec** for debugging running containers
- **Consider Elastic IP** for stable IP address without load balancer
- **Add secrets management** with AWS Secrets Manager
- **Use Fargate Spot** to reduce costs by ~70% (see DEPLOYMENT.md)

## Resources

- [AWS ECR Documentation](https://docs.aws.amazon.com/ecr/)
- [AWS ECS Documentation](https://docs.aws.amazon.com/ecs/)
- [AWS Fargate Documentation](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html)
- [Terraform AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
- [Terraform Docker Provider](https://registry.terraform.io/providers/kreuzwerker/docker/latest/docs)
- [ECS Task Definition Parameters](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html)
- [Fargate Pricing](https://aws.amazon.com/fargate/pricing/)
